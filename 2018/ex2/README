#messy count_components
# def count_components(g) :
#     vertices = g.get_vertices()
#     #print('vertices: {}'.format(vertices))
#
#     numcomponents=0
#     while vertices:
#         #loops as long as vertices set is not empty
#         #v=vertices.pop() #pops item out of set and stores it in v so 
I can use it
#
#         #this doesn't remove the initial node, so I don't have to use 
the
#         #commented out try/except clause to escape attempting to 
remove
#         #a nonexisting element in the set
#         for v in vertices:
#             vertex=v
#             break;
#         #this way, I can get vertex from the vertices set without 
popping
#
#         reached=breadth_first_search(g,vertex) #get dict of reached 
nodes
#         # print('vertices: {}'.format(vertices))
#         # print('reached: ')
#         # print(reached)
#         # print()
#         #print(reached.items())
#
#         #abandoned this, because it turns the dictionary to a alist
#         #which might be slower to access, if I understood the 
assignment description correctly
#         # for node, reached_from in reached.items():
#         #     print('{} {}'.format(node,reached_from)
#
#
#         for node in reached:
#             # print(vertices)
#             vertices.remove(node)
#             #it works, but this is sloppy
#             # try:
#             #     vertices.remove(node)
#             # except:
#             #     pass
#
#         numcomponents += 1
#
#     print(numcomponents)
#     return numcomponents
